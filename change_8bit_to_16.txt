	преобразовать 8-битный массив в 16-битный
	8-битный приходит по usb-com
	16-битный - то что надо нам
	
	========== 1 =============
	volatile	uint8_t temp_value1 ; // младший байт, допустим адрес 0х2000053c
	volatile	uint8_t temp_value2 ; // старший будет байт, адрес его должен быть 0х2000053d
	volatile	uint16_t temp_value16; // 16-битное слово, то что нам надо, но лежать будет по другому адресу, можно и не нужно
	volatile	uint16_t * temp_adr16; // темповое значение адреса, нужно для перекидоса
	
		// вот так это например при использовании промежуточной  & temp_adr16
	temp_adr16 =  &temp_value1;
	temp_value16 = *( (uint16_t *) &temp_value1);
	
		// или вот так, без temp_adr16,  но запутано и непонятно
	temp_value16 = *( (uint16_t *) &temp_value1);
	
		// результат должен быть таким в обоих случаях
	temp_value1 =0x01 ; // младший байт, допустим адрес 0х2000053c
	temp_value2 =0x02 ; // старший будет байт, адрес его должен быть 0х2000053d
	результат =====>> 0x0201 ==>> temp_value16